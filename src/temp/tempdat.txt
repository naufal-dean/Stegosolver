from PIL import Image
from util.lsb_helper import LSBHelper
from os.path import isfile,join

import cv2
import glob
import math
import numpy as np
import os
import subprocess

class StegoVideo:
    def __init__(self, mode, key, in_path, out_path, data_path, frame_seq, pixel_seq):
        self.mode = mode
        self.key = key
        self.in_path = in_path
        self.out_path = out_path
        self.data_path = data_path
        self.frame_seq = frame_seq
        self.pixel_seq = pixel_seq

        self.TEMP_FOLDER = './temp'
        self.nframes = 0
        self.framesize = 0
        self.extract_frames()

    ### Extended Vigenere cipher ###
    def encrypt_data(self):
        # Open file to get byte data
        in_file = open(self.data_path, 'rb')
        data = in_file.read()
        in_file.close()

        enc_bytes = bytearray()
        for i in range(len(data)):
            proc_byte = (data[i] + ord(self.key[i % len(self.key)])) % 256
            enc_bytes.append(proc_byte)
        
        return enc_bytes

    def decrypt_data(self, data):
        dec_bytes = bytearray()
        for i in range(len(data)):
            proc_byte = (data[i] - ord(self.key[i % len(self.key)])) % 256
            dec_bytes.append(proc_byte)

        return dec_bytes


    ### ffmpeg utils ##
    def ffmpeg_playvideo(self, vidpath):
        subprocess.call(["ffplay", vidpath], stdout=open(os.devnull, "w"), stderr=subprocess.STDOUT)

    ### Functions utils ###
    def is_enough(self):
        f = open(self.in_path, 'rb')
        filesize = len(f.read())
        f.close()

        return self.nframes * (self.framesize - 1)  >= filesize

    def get_rand_seed(self):
        temp = 0
        for i in range(len(self.key)):
            temp += ord(self.key[i])
        return 
        
    def set_info(self, nframes, is_fr_seq):
        fr1 = open('{}/0.png'.format(self.TEMP_FOLDER), 'rb')
        dat = list(fr1.read())
        fr1.close()

        seed = self.get_rand_seed()

        n = list(int(nframes).to_bytes(8, byteorder='big'))
        if is_fr_seq:
            n.append(1)
        else:
            n.append(0)
        
        new_container = LSBHelper.insert_data_as_lsb(bytes(dat), True, 'a', bytes(n), seed)

        fr1 = open('{}/0.png'.format(self.TEMP_FOLDER), 'wb')
        fr1.write(bytes(new_container))
        fr1.close()
    
    def get_info(self):
        fr1 = open('{}/0.png'.format(self.TEMP_FOLDER), 'rb')
        dat = fr1.read()
        fr1.close()

        seed = self.get_rand_seed()

        sink, content = LSBHelper.extract_data_from_lsb(dat, seed)
        content = list(content)
        nframes = int.from_bytes(bytes(content[:8]), byteorder='big')
        is_fr_seq = content[-1]
        return nframes, is_fr_seq


    def hide_lsb(self, data):
        size = math.ceil(len(data)/self.framesize)
        part_size = math.ceil(len(data)/size)
        data_arr = [data[i:i+part_size] for i in range(0, len(data), part_size)]
        seed = self.get_rand_seed()

        self.set_info(len(data_arr), self.frame_seq)
        self.get_info()

        if not self.frame_seq:
            np.random.seed(seed)
            rand_arr = np.random.choice(range(1, self.nframes+1), size=len(data_arr), replace=False)

            it = 0
            for fr in rand_arr:
                filename = '{}.png'.format(fr)
                frame_file = '{}/{}.png'.format(self.TEMP_FOLDER, fr)

                f = open(frame_file, 'rb')
                container = f.read()
                f.close()

                new_container = LSBHelper.insert_data_as_lsb(container, self.pixel_seq, filename, data_arr[it], seed)
                new_container = bytes(new_container)

                f.open(frame_file, 'wb')
                f.write(new_container)
                f.close()
                it += 1

        else:
            for i in range(len(data_arr)):
                filename = '{}.png'.format(i+1)
                frame_file = '{}/{}.png'.format(self.TEMP_FOLDER, i+1)
                print(frame_file)

                f = open(frame_file, 'rb')
                container = f.read()
                f.close()

                print(data_arr[i])
                new_container = LSBHelper.insert_data_as_lsb(container, self.pixel_seq, filename, data_arr[i], seed)

                new_container = bytes(new_container)

                f = open(frame_file, 'wb')
                f.write(new_container)
                f.close()                

        
    def extract_lsb(self):
        seed = self.get_rand_seed()
        full_content = b''
        nhideframes, is_fr_seq = 1, True
        self.frame_seq = is_fr_seq

        if not self.frame_seq:
            np.random.seed(seed)
            rand_arr = np.random.choice(range(1, self.nframes+1), size=nhideframes, replace=False)
            print(rand_arr)
            for fr in rand_arr:
                frame_file = '{}/{}.png'.format(self.TEMP_FOLDER, fr)

                f = open(frame_file, 'rb')
                container = f.read()
                f.close()

                sink, content = LSBHelper.extract_data_from_lsb(container, seed)
                full_content += content

        else:
            for i in range(1, nhideframes):
                frame_file = '{}/{}.png'.format(self.TEMP_FOLDER, i)

                f = open(frame_file, 'rb')
                container = f.read()
                f.close()

                sink, content = LSBHelper.extract_data_from_lsb(container, seed)
                print(sink)
                print(content)
                full_content += content

        return full_content
        

    def extract_frames(self):
        # Init temp folder for storing frames
        captures = cv2.VideoCapture(self.in_path)
        it = 0

        while True:
            success, image = captures.read()

            # If all frames are captured
            if not success:
                break

            # Save all frames to temporary folder
            cv2.imwrite(os.path.join(self.TEMP_FOLDER, "{}.png".format(it)), image)
            it += 1
            self.nframes += 1
        
        # Save the size, sample from first frame
        frame = Image.open('{}/0.png'.format(self.TEMP_FOLDER))
        width, height = frame.size
        self.framesize = width * height

    def to_video(self):
        fc = cv2.VideoWriter_fourcc('R', 'G', 'B', 'A')
        
        frame = Image.open('{}/0.png'.format(self.TEMP_FOLDER))
        width, height = frame.size
        
        out = cv2.VideoWriter('project.avi', fc, 30, (width, height))
        
        for i in range(self.nframes):
            img = cv2.imread('{}/{}.png'.format(self.TEMP_FOLDER, i))
            out.write(img)
        out.release()   

    def hide(self):
        f = open(self.data_path, 'rb')
        data = f.read()
        f.close()

        self.hide_lsb(data)
        self.to_video()

    def extract(self):
        file = self.extract_lsb()

        f = open(self.out_path, 'wb')
        f.write(file)
        f.close()

    def run(self):
        if not self.is_enough():
            print("NOT ENOUGH FILESIZE")
            return
        if self.mode == 'hide':
            self.hide()
        elif self.mode == 'extract':
            self.extract()
        
if __name__ == '__main__':
    mode = 'hide'
    key = 'test'
    in_path = './b.avi'
    out_path = 'video.avi'
    data_path = './a.txt'
    frame_seq = True
    pixel_seq = True

    runner = StegoVideo(mode, key, in_path, out_path, data_path, frame_seq, pixel_seq)
    runner.run()